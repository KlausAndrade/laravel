Laracast docs

https://laratrust.santigarcor.me/docs/6.x/

Introduction

easily roles and permissions inside your application

Installation

composer require santigarcor/laratrust

php artisan vendor:publish --tag="laratrust"

Caso não funcione rode
php artisan config:clear

composer dumpautoload

php artisan laratrust:setup

php artisan migrate

Implementar Auth

$this->call(LaratrustSeeder::class);
php artisan ui bootstrap --auth
npm install && npm run dev
npm audit fix

Testar

php artisan serve

http://localhost:8000/home


The Team model has three main attributes:

    name — Unique name for the Team, used for looking up team information in the application layer. For example: "my-team", "my-company".
    display_name — Human readable name for the Team. Not necessarily unique and optional. For example: "My Team", "My Company".
    description — A more detailed explanation of what the Team does. Also, optional.





If you want to change the foreign key name to check for, you can pass a second attribute to the method:

public function update (Post $post) {
    if ($user->owns($post, 'idUser')) { //This will check for 'idUser' inside the $post
        abort(403);
    }

    ...
}

#
Permissions, Roles & Ownership Checks

If you want to check if a user can do something or has a role, and also is the owner of an object you can use the isAbleToAndOwns and hasRoleAndOwns methods:

Both methods accept three parameters:

    permission or role are the permission or role to check (This can be an array of roles or permissions).
    thing is the object used to check the ownership.
    options is a set of options to change the method behavior (optional).

The third parameter is an options array:

$options = [
    'requireAll' => true, //Default: false,
    'foreignKeyName'  => 'canBeAnyString' //Default: null
];

Here's an example of the usage of both methods:

$post = Post::find(1);
$user->isAbleToAndOwns('edit-post', $post);
$user->isAbleToAndOwns(['edit-post', 'delete-post'], $post);
$user->isAbleToAndOwns(['edit-post', 'delete-post'], $post, ['requireAll' => false, 'foreignKeyName' => 'writer_id']);

$user->hasRoleAndOwns('admin', $post);
$user->hasRoleAndOwns(['admin', 'writer'], $post);
$user->hasRoleAndOwns(['admin', 'writer'], $post, ['requireAll' => false, 'foreignKeyName' => 'writer_id']);

The Laratrust class has a shortcut to owns(), isAbleToAndOwns and hasRoleAndOwns methods for the currently logged in user:

Laratrust::owns($post);
Laratrust::owns($post, 'idUser');

Laratrust::isAbleToAndOwns('edit-post', $post);
Laratrust::isAbleToAndOwns(['edit-post', 'delete-post'], $post, ['requireAll' => false, 'foreignKeyName' => 'writer_id']);

Laratrust::hasRoleAndOwns('admin', $post);
Laratrust::hasRoleAndOwns(['admin', 'writer'], $post, ['requireAll' => false, 'foreignKeyName' => 'writer_id']);

#
Ownable Interface

If the object ownership is resolved through a more complex logic you can implement the Ownable interface so you can use the owns, isAbleToAndOwns and hasRoleAndOwns methods in those cases:

class SomeOwnedObject implements \Laratrust\Contracts\Ownable
{
    ...

    public function ownerKey($owner)
    {
        return $this->someRelationship->user->id;
    }

    ...
}

IMPORTANT

    The ownerKey method must return the object's owner id value.
    The ownerKey method receives as a parameter the object that called the owns method.

After implementing it, you simply do:

$user = User::find(1);
$theObject = new SomeOwnedObject;
$user->owns($theObject);            // This will return true or false depending on what the ownerKey method returns

Multiple User Models

Laratrust supports attaching roles/permissions to multiple user models.

In the config/laratrust.php file you will find an user_models array, it contains the information about the multiple user models and the name of the relationships inside the Role and Permission models. For example:

'user_models' => [
    'users' => 'App\User',
],

NOTE

The value of the key in the key => value pair defines the name of the relationship inside the Role and Permission models.

It means that there is only one user model using Laratrust, and the relationship with the Role and Permission models is going to be called like this:

$role->users;
$role->users();

NOTE

Inside the role_user and permission_user tables the user_type column will be set with the user's fully qualified class name, as the polymorphic

relations describe it in Laravel docs.

If you want to use the MorphMap feature just change the use_morph_map value to true in Laratrust's configuration file.

Events

Laratrust comes with an events system that works like the Laravel model events

. The events that you can listen to are roleAttached, roleDetached, permissionAttached, permissionDetached, roleSynced, permissionSynced.

NOTE

Inside the Role model only the permissionAttached, permissionDetached and permissionSynced events will be fired.

If you want to listen to a Laratrust event, inside your User or Role models put this:

<?php

namespace App;

use Laratrust\Traits\LaratrustUserTrait;

class User extends Model
{
    use LaratrustUserTrait;

    public static function boot() {
        parent::boot();

        static::roleAttached(function($user, $role, $team) {
        });
        static::roleSynced(function($user, $changes, $team) {
        });
    }
}

NOTE

The $team parameter is optional and if you are not using teams, it will be set to null.

The eventing system also supports observable classes:

<?php

namespace App\Observers;

use App\User;

class UserObserver
{

    public function roleAttached(User $user, $role, $team)
    {
        //
    }

    public function roleSynced(User $user, $changes, $team)
    {
        //
    }
}

IMPORTANT

To register an observer, use the laratrustObserve method on the model you wish to observe.

You may register observers in the boot method of one of your service providers. In this example, we'll register the observer in the AppServiceProvider:

<?php

namespace App\Providers;

use App\User;
use App\Observers\UserObserver;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{

    public function boot()
    {
        User::laratrustObserve(UserObserver::class);
    }

    ...
}

NOTE

    Inside your observable classes you can have your normal model events methods alongside Laratrust's events methods.
    If you wan to register Laratrust events and also eloquent events yo should call both observe and laratrustObserve methods.

#
Flushing events and observables

If you want to flush the observables and events from laratrust you should add the following in your code:

User::laratrustFlushObservables();
User::flushEventListeners();

#
Available Events
#
User Events

    roleAttached($user, $role, $team = null)
        $user: The user to whom the role was attached.
        $role: The role id that was attached to the $user.
        $team: The team id that was used to attach the role to the $user.

    roleDetached($user, $role, $team = null)
        $user: The user to whom the role was detached.
        $role: The role id that was detached from the $user.
        $team: The team id that was used to detach the role from the $user.

    permissionAttached($user, $permission, $team = null)
        $user: The user to whom the permission was attached.
        $permission: The permission id that was attached to the $user.
        $team: The team id that was used to attach the permission to the $user.

    permissionDetached($user, $permission, $team = null)
        $user: The user to whom the permission was detached.
        $permission: The permission id that was detached from the $user.
        $team: The team id that was used to detach the permission from the $user.

    roleSynced($user, $changes, $team)
        $user: The user to whom the roles were synced.
        $changes: The value returned by the eloquent sync method containing the changes made in the database.
        $team: The team id that was used to sync the roles to the user.

    permissionSynced()
        $user: The user to whom the permissions were synced.
        $changes: The value returned by the eloquent sync method containing the changes made in the database.
        $team: The team id that was used to sync the permissions to the user.

#
Role Events

    permissionAttached($role, $permission)
        $role: The role to whom the permission was attached.
        $permission: The permission id that was attached to the $role.

    permissionDetached($role, $permission)
        $role: The role to whom the permission was detached.
        $permission: The permission id that was detached from the $role.

    permissionSynced()
        $role: The role to whom the permissions were synced.
        $changes: The value returned by the eloquent sync method containing the changes made in the database.

Middleware
#
Configuration

The middleware are registered automatically as role, permission and ability . If you want to change or customize them, go to your config/laratrust.php and set the middleware.register value to false and add the following to the routeMiddleware array in app/Http/Kernel.php:

'role' => \Laratrust\Middleware\LaratrustRole::class,
'permission' => \Laratrust\Middleware\LaratrustPermission::class,
'ability' => \Laratrust\Middleware\LaratrustAbility::class,

#
Concepts

You can use a middleware to filter routes and route groups by permission, role or ability:

Route::group(['prefix' => 'admin', 'middleware' => ['role:admin']], function() {
    Route::get('/', 'AdminController@welcome');
    Route::get('/manage', ['middleware' => ['permission:manage-admins'], 'uses' => 'AdminController@manageAdmins']);
});

If you use the pipe symbol it will be an OR operation:

'middleware' => ['role:admin|root']
// $user->hasRole(['admin', 'root']);

'middleware' => ['permission:edit-post|edit-user']
// $user->hasRole(['edit-post', 'edit-user']);

To emulate AND functionality you can do:

'middleware' => ['role:owner|writer,require_all']
// $user->hasRole(['owner', 'writer'], true);

'middleware' => ['permission:edit-post|edit-user,require_all']
// $user->isAbleTo(['edit-post', 'edit-user'], true);

For more complex situations use ability middleware which accepts 3 parameters; roles, permissions and options:

'middleware' => ['ability:admin|owner,create-post|edit-user,require_all']
// $user->ability(['admin', 'owner'], ['create-post', 'edit-user'], true)

#
Using Different Guards

If you want to use a different guard for the user check you can specify it as an option:

'middleware' => ['role:owner|writer,require_all|guard:api']
'middleware' => ['permission:edit-post|edit-user,guard:some_new_guard']
'middleware' => ['ability:admin|owner,create-post|edit-user,require_all|guard:web']

#
Teams

If you are using the teams feature and want to use the middleware checking for your teams, you can use:

'middleware' => ['role:admin|root,my-awesome-team,require_all']
// $user->hasRole(['admin', 'root'], 'my-awesome-team', true);

'middleware' => ['permission:edit-post|edit-user,my-awesome-team,require_all']
// $user->hasRole(['edit-post', 'edit-user'], 'my-awesome-team', true);

'middleware' => ['ability:admin|owner,create-post|edit-user,my-awesome-team,require_all']
// $user->ability(['admin', 'owner'], ['create-post', 'edit-user'], 'my-awesome-team', true);

NOTE

The require_all and guard parameters are optional.
#
Middleware Return

The middleware supports two types of returns in case the check fails. You can configure the return type and the value in the config/laratrust.php file.
#
Abort

By default the middleware aborts with a code 403 but you can customize it by changing the middleware.handlers.abort.code value.
#
Redirect

To make a redirection in case the middleware check fails, you will need to change the middleware.handling value to redirect and the middleware.handlers.redirect.url to the route you need to be redirected. Leaving the configuration like this:

'handling' => 'redirect',
'handlers' => [
    'abort' => [
        'code' => 403
    ],
    'redirect' => [
        'url' => '/home',       // Change this to the route you need
        'message' => [          // Key value message to be flashed into the session.
            'key' => 'error',
            'content' => ''     // If the content is empty nothing will be flashed to the session.
        ]
    ]
]

Soft Deleting

The default migration takes advantage of onDelete('cascade') clauses within the pivot tables to remove relations when a parent record is deleted. If for some reason you can not use cascading deletes in your database, the LaratrustRole and LaratrustPermission classes, and the HasRole trait include event listeners to manually delete records in relevant pivot tables.

In the interest of not accidentally deleting data, the event listeners will not delete pivot data if the model uses soft deleting. However, due to limitations in Laravel's event listeners, there is no way to distinguish between a call to delete() versus a call to forceDelete(). For this reason, before you force delete a model, you must manually delete any of the relationship data (unless your pivot tables uses cascading deletes). For example:

$role = Role::findOrFail(1); // Pull back a given role

// Regular Delete
$role->delete(); // This will work no matter what

// Force Delete
$role->users()->sync([]); // Delete relationship data
$role->permissions()->sync([]); // Delete relationship data

$role->forceDelete(); // Now force delete will work regardless of whether the pivot table has cascading delete

Blade Templates

Five directives are available for use within your Blade templates. What you give as the directive arguments will be directly passed to the corresponding Laratrust function:

@role('admin')
    <p>This is visible to users with the admin role. Gets translated to
    \Laratrust::hasRole('admin')</p>
@endrole

@permission('manage-admins')
    <p>This is visible to users with the given permissions. Gets translated to
    \Laratrust::isAbleTo('manage-admins'). The @can directive is already taken by core
    laravel authorization package, hence the @permission directive instead.</p>
@endpermission

@ability('admin,owner', 'create-post,edit-user')
    <p>This is visible to users with the given abilities. Gets translated to
    \Laratrust::ability('admin,owner', 'create-post,edit-user')</p>
@endability

@isAbleToAndOwns('edit-post', $post)
    <p>This is visible if the user has the permission and owns the object. Gets translated to
    \Laratrust::isAbleToAndOwns('edit-post', $post)</p>
@endOwns

@hasRoleAndOwns('admin', $post)
    <p>This is visible if the user has the role and owns the object. Gets translated to
    \Laratrust::hasRoleAndOwns('admin', $post)</p>
@endOwns

Seeder

Laratrust comes with a database seeder, this seeder helps you fill the permissions for each role depending on the module, and creates one user for each role.

NOTE

    The seeder is going to work with the first user model inside the user_models array.

    The seeder doesn't support teams.

To generate the seeder you have to run:

php artisan laratrust:seeder

and

composer dump-autoload

In the database/seeds/DatabaseSeeder.php file you have to add this to the run method:

$this->call(LaratrustSeeder::class);

NOTE

If you have not run php artisan vendor:publish --tag="laratrust" you should run it in order to customize the roles, modules and permissions in each case.

Your config/laratrust_seeder.php file looks like this by default:

return [
    ...
    'roles_structure' => [
        'superadministrator' => [
            'users' => 'c,r,u,d',
            'payments' => 'c,r,u,d',
            'profile' => 'r,u'
        ],
        'administrator' => [
            'users' => 'c,r,u,d',
            'profile' => 'r,u'
        ],
        'user' => [
            'profile' => 'r,u',
        ],
        'role_name' => [
            'module_1_name' => 'c,r,u,d',
        ]
    ],
    'permissions_map' => [
        'c' => 'create',
        'r' => 'read',
        'u' => 'update',
        'd' => 'delete'
    ],
    ...
];

To understand the role_structure you must know:

    The first level represents the roles.
    The second level represents the modules.
    The second level assignments are the permissions.

With that in mind, you should arrange your roles, modules and permissions like this:

return [
    'role_structure' => [
        'role' => [
            'module' => 'permissions',
        ],
    ]
];

#
Permissions

In case that you do not want to use the c,r,u,d permissions, you should change the permissions_map.

For example:

return [
    ...
    'roles_structure' => [
        'role_name' => [
            'module_1_name' => 'a,s,e,d',
        ]
    ],
    'permissions_map' => [
        'a' => 'add',
        's' => 'show',
        'e' => 'edit',
        'd' => 'destroy'
    ],
    ...
];

Administration Panel

Laratrust comes with a simple administration panel for roles, permissions and their assignment to the users.

Currently it supports:

    Permissions CRUD.
    Roles CRUD and permissions assignment.
    Assignment of roles and permission to the multiple users defined in user_models in the config/laratrust.php file.
    Restricting roles from being edited, deleted or removed.

#
How to use it

    Go to your config/laratrust.php file and change the panel.register value to true.
    Publish the assets used by the panel by running:

php artisan vendor:publish --tag=laratrust-assets --force

By default the URL to access the panel is /laratrust.

To customize the the URL and other available settings in the panel please go to the panel section in the config/laratrust.php file.
#
Screenshots


